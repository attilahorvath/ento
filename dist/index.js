!function(){"use strict";class t{constructor(t,e){this.index=t,this.generation=e}}class e{constructor(t,e){this.entries=[...Array(t)].map(()=>({active:!1,generation:0,component:new e}))}allocate(t,e={resetComponent:!1}){const i=this.entries[t.index];return i.generation<=t.generation?(i.active=!0,i.generation=t.generation,e.resetComponent&&i.component.constructor(),i.component):null}fetch(t){const e=this.entries[t.index];return e.generation===t.generation&&e.active?e.component:null}deallocate(t){this.entries[t.index].active=!1}*activeEntries(){for(let e=0;e<this.entries.length;e++){const i=this.entries[e];i.active&&(yield{entityIndex:new t(e,i.generation),component:i.component})}}}class i{constructor(t){this.capacity=t,this.componentArrays=new Map}register(t){this.componentArrays.set(t,new e(this.capacity,t))}components(t){return this.componentArrays.get(t)}deallocateAll(t){this.componentArrays.values().forEach(e=>e.deallocate(t))}}var s={Position:function(){this.x=0,this.y=0},Sprite:function(){this.width=50,this.height=25},Input:function(){},Tilemap:function(){}};class r{constructor(t){this.entities=[...Array(t)].map(()=>({active:!1,generation:0}))}allocate(){const e=this.entities.findIndex(t=>!t.active),i=this.entities[e];return i&&!i.active?(i.active=!0,i.generation+=1,new t(e,i.generation)):null}deallocate(t){const e=this.entities[t.index];e.generation===t.generation&&(e.active=!1)}}var a="uniform mat4 projection;uniform mat4 view;attribute vec3 vertex0Position;attribute vec4 vertex1Color;varying vec4 color;void main(){gl_Position=projection*view*vec4(vertex0Position,1.0);color=vertex1Color;}",n="precision highp float;varying vec4 color;void main(){gl_FragColor=color;}";class h{constructor(t,e,i){this.vertexShader=t.createShader(t.VERTEX_SHADER),t.shaderSource(this.vertexShader,e),t.compileShader(this.vertexShader),this.fragmentShader=t.createShader(t.FRAGMENT_SHADER),t.shaderSource(this.fragmentShader,i),t.compileShader(this.fragmentShader),this.program=t.createProgram(),t.attachShader(this.program,this.vertexShader),t.attachShader(this.program,this.fragmentShader),t.linkProgram(this.program),this.uniforms=this.loadUniforms(t),this.attributes=this.loadAttributes(t),this.size=this.attributes.reduce((t,e)=>t+e.size,0),this.stride=this.size*Float32Array.BYTES_PER_ELEMENT}loadUniforms(t){const e=t.getProgramParameter(this.program,t.ACTIVE_UNIFORMS);return[...Array(e)].map((e,i)=>{const s=t.getActiveUniform(this.program,i),r=t.getUniformLocation(this.program,s.name);return this[s.name]=null,{type:s.type,name:s.name,location:r}})}loadAttributes(t){const e=t.getProgramParameter(this.program,t.ACTIVE_ATTRIBUTES);return[...Array(e)].map((e,i)=>{const s=t.getActiveAttrib(this.program,i),r=t.getAttribLocation(this.program,s.name),a=this.constructor.attributeSize(t,s.type);return{name:s.name,location:r,size:a}}).sort((t,e)=>t.name.localeCompare(e.name))}use(t){t.useProgram(this.program),this.useAttributes(t),this.useUniforms(t)}useAttributes(t){let e=0;this.attributes.forEach(i=>{t.enableVertexAttribArray(i.location),t.vertexAttribPointer(i.location,i.size,t.FLOAT,!1,this.stride,e),e+=i.size*Float32Array.BYTES_PER_ELEMENT})}useUniforms(t){this.uniforms.forEach(e=>{switch(e.type){case t.FLOAT:t.uniform1f(e.location,this[e.name]);break;case t.FLOAT_VEC2:t.uniform2fv(e.location,this[e.name]);break;case t.FLOAT_VEC3:t.uniform3fv(e.location,this[e.name]);break;case t.FLOAT_VEC4:t.uniform4fv(e.location,this[e.name]);break;case t.FLOAT_MAT2:t.uniformMatrix2fv(e.location,!1,this[e.name]);break;case t.FLOAT_MAT3:t.uniformMatrix3fv(e.location,!1,this[e.name]);break;case t.FLOAT_MAT4:t.uniformMatrix4fv(e.location,!1,this[e.name])}})}static attributeSize(t,e){switch(e){case t.FLOAT:return 1;case t.FLOAT_VEC2:return 2;case t.FLOAT_VEC3:return 3;case t.FLOAT_VEC4:case t.FLOAT_MAT2:return 4;case t.FLOAT_MAT3:return 9;case t.FLOAT_MAT4:return 16;default:return 0}}}class o{constructor(t,e){this.width=t,this.height=e,this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.height,document.body.appendChild(this.canvas),this.gl=this.canvas.getContext("webgl"),this.gl.clearColor(0,0,0,1),this.spriteShader=new h(this.gl,a,n),this.projection=new Float32Array([2/this.width,0,0,0,0,-2/this.height,0,0,0,0,-1,0,-1,1,0,1]),this.view=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}clear(){this.gl.clear(this.gl.COLOR_BUFFER_BIT)}createVertexBuffer(t){const e=this.gl.createBuffer();return this.gl.bindBuffer(this.gl.ARRAY_BUFFER,e),this.gl.bufferData(this.gl.ARRAY_BUFFER,t,this.gl.STATIC_DRAW),e}updateVertexBuffer(t,e){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,t),this.gl.bufferData(this.gl.ARRAY_BUFFER,e,this.gl.STATIC_DRAW)}draw(t,e,i){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,e),t.projection=this.projection,t.view=this.view,t.use(this.gl),this.gl.drawArrays(this.gl.TRIANGLES,0,i)}}const c=new class{constructor(t={maxEntities:10,width:300,height:150}){this.maxEntities=t.maxEntities,this.width=t.width,this.height=t.height,this.allocator=new r(this.maxEntities),this.state=new i(this.maxEntities),Object.keys(s).forEach(t=>{this.state.register(s[t])}),this.renderer=new o(this.width,this.height),this.systems=[],this.lastTime=0}allocateEntity(){return this.allocator.allocate()}deallocateEntity(t){this.allocator.deallocate(t),this.state.deallocateAll(t)}allocateComponent(t,e){return this.state.components(e).allocate(t)}fetchComponent(t,e){return this.state.components(e).fetch(t)}*entitiesWith(t){yield*this.state.components(t).activeEntries()}createEntity(t){const e=this.allocateEntity();return Object.keys(t).forEach(i=>{const r=this.allocateComponent(e,s[i]);Object.keys(t[i]).forEach(e=>{r[e]=t[i][e]})}),e}addSystem(t){this.systems.push(new t(this))}run(){requestAnimationFrame(t=>this.update(t))}update(t){requestAnimationFrame(t=>this.update(t));const e=t-this.lastTime;this.lastTime=t,this.renderer.clear(),this.systems.forEach(t=>t.run(e))}};c.addSystem(class{constructor(t){this.game=t,this.renderer=this.game.renderer,this.up=!1,this.down=!1,this.left=!1,this.right=!1,document.addEventListener("keydown",t=>this.keyDown(t)),document.addEventListener("keyup",t=>this.keyUp(t))}keyDown(t){switch(t.keyCode){case 38:case 87:case 75:this.up=!0,t.preventDefault();break;case 40:case 83:case 74:this.down=!0,t.preventDefault();break;case 37:case 65:case 72:this.left=!0,t.preventDefault();break;case 39:case 68:case 76:this.right=!0,t.preventDefault()}}keyUp(t){switch(t.keyCode){case 38:case 87:case 75:this.up=!1,t.preventDefault();break;case 40:case 83:case 74:this.down=!1,t.preventDefault();break;case 37:case 65:case 72:this.left=!1,t.preventDefault();break;case 39:case 68:case 76:this.right=!1,t.preventDefault()}}run(t){for(const{entityIndex:e}of this.game.entitiesWith(s.Input)){const i=this.game.fetchComponent(e,s.Position);this.up&&(i.y-=.1*t),this.down&&(i.y+=.1*t),this.left&&(i.x-=.1*t),this.right&&(i.x+=.1*t)}}}),c.addSystem(class{constructor(t){this.game=t,this.renderer=this.game.renderer,this.vertices=new Float32Array(this.game.maxEntities*this.renderer.spriteShader.stride*2),this.vertexBuffer=this.renderer.createVertexBuffer(this.vertices)}run(){let t=0;for(const{entityIndex:e,component:i}of this.game.entitiesWith(s.Sprite)){const r=this.game.fetchComponent(e,s.Position);this.vertices[t++]=r.x,this.vertices[t++]=r.y,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=0,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=r.x+i.width,this.vertices[t++]=r.y,this.vertices[t++]=0,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=r.x,this.vertices[t++]=r.y+i.height,this.vertices[t++]=0,this.vertices[t++]=0,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=1,this.vertices[t++]=r.x+i.width,this.vertices[t++]=r.y,this.vertices[t++]=0,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=r.x,this.vertices[t++]=r.y+i.height,this.vertices[t++]=0,this.vertices[t++]=0,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=1,this.vertices[t++]=r.x+i.width,this.vertices[t++]=r.y+i.height,this.vertices[t++]=0,this.vertices[t++]=1,this.vertices[t++]=1,this.vertices[t++]=0,this.vertices[t++]=1}this.renderer.updateVertexBuffer(this.vertexBuffer,this.vertices),this.renderer.draw(this.renderer.spriteShader,this.vertexBuffer,t/this.renderer.spriteShader.size)}}),c.createEntity({Tilemap:{}}),c.createEntity({Position:{x:20,y:10},Sprite:{width:10,height:10},Input:{}}),c.createEntity({Position:{x:50,y:30},Sprite:{width:10,height:20},Input:{}}),c.run()}();
